<script lang="ts" setup>
import sendImg from '@/assets/img/play/Mid2.png';
import { useChatUsersStore } from '@/stores/ChatUsers';
import { useMessageStore } from '@/stores/MessageStore';
import { useCurrentMessageStore } from "@/stores/CurrentMessageStore";
import { useStatusInfo } from '@/stores/StatusInfo';
import { getWebSocket } from '@/utils/websocketService';
const statusStore = useStatusInfo();
const CurrentMessageStore = useCurrentMessageStore();
const MessageStore = useMessageStore();
const chatUsersStore = useChatUsersStore();
import router from "@/router";
import { onActivated, ref, watch } from 'vue';
import { onBeforeRouteLeave, useRoute } from 'vue-router';
const route = useRoute();

let nickname = ref();
let avatarId = ref<string | null>("");
let prevUserList = ref([]);
let socket: WebSocket;

// ç”¨æˆ·æ•°é‡
let userCount = ref(0);

// ç”¨æˆ·åˆ—è¡¨
let userList = ref([]);

// ä¿¡æ¯æ¡†
let text = ref("");

// ä¿¡æ¯åˆ—è¡¨
let messages = ref([]);

const message = {
    avatar: "",
    name: "",
    time: "",
    msg: "",
}
const portalMsges = ref([]);
let room = ref();

watch(() => route.query.id, (newValue) => {
    room.value = newValue;
}, { immediate: true })


const lastExecuted = ref(0);
const messageCount = ref(0);
const isBlocked = ref(false); // æ ‡å¿—ä½ï¼ŒæŒ‡ç¤ºæ˜¯å¦å¤„äºç¦æ­¢çŠ¶æ€
const debounceTime = 5000; // 5ç§’
const throttleTime = 10000; // 10ç§’
// å‘é€éŸ³ä¹ä¿¡æ¯ç»™æ–°ç”¨æˆ·
const sendCurrentMusicInfo = (newUser: any) => {
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
            type: 'musicInfo',
            data: {
                currentIndex: statusStore.currentSongIndex,
                currentTime: statusStore.currentSongTime  //è·å–å½“å‰éŸ³ä¹çš„æ’­æ”¾åˆ°å“ªé‡Œäº†çš„æ—¶é—´
            },
            user: newUser
        }));
    }
};

watch(
    () => userList.value.slice(), // å¤åˆ¶ä¸€ä»½ userList
    (newUserList, oldUserList) => {
        if (newUserList != null) {
            // ä½¿ç”¨ set æ¥å¤„ç†ç”¨æˆ·çš„å”¯ä¸€æ€§å’Œæ¯”è¾ƒ
            const oldUserSet = new Set(oldUserList.map(user => user.username));
            const newUser = newUserList.find(user => !oldUserSet.has(user.username));
            if (newUser && userList.value[0].username === nickname.value) {
                // æœ‰æ–°ç”¨æˆ·åŠ å…¥ï¼Œå‘é€éŸ³ä¹ä¿¡æ¯
                statusStore.addCount();
                setTimeout(() => {
                    console.log("æ–°ç”¨æˆ·åŠ å…¥ï¼š", newUser.username);
                    sendCurrentMusicInfo(newUser.username);
                }, 2000)

            }
        }

    },
    { deep: true }
);

const sendMessage = () => {
    const currentTime = Date.now();
    const timeElapsed = currentTime - lastExecuted.value;

    if (isBlocked.value) {
        ElMessage({
            type: 'error',
            customClass: 'msgInfo',
            plain: true,
            message: 'ğŸ¥ å‘é€é¢‘ç¹ï¼Œè¯·ç¨åå†è¯•~',
        });
        return;
    }

    if (timeElapsed < debounceTime) {
        messageCount.value += 1;
    } else {
        messageCount.value = 1; // Reset count
    }

    lastExecuted.value = currentTime;

    if (messageCount.value > 5) {
        // è¶…è¿‡é™åˆ¶æ¬¡æ•°ï¼Œç¦ç”¨æ“ä½œå¹¶å¼¹çª—
        isBlocked.value = true;
        setTimeout(() => {
            isBlocked.value = false; // è§£é”çŠ¶æ€
        }, throttleTime); // ç¦ç”¨æ—¶é—´
        ElMessage({
            type: 'error',
            customClass: 'msgInfo',
            plain: true,
            message: 'ğŸ¥ å‘é€é¢‘ç¹ï¼Œè¯·ç¨å~',
        });
        return;
    }

    if (text.value != null && text.value !== "" && nickname.value != null) {
        message.name = nickname.value;
        message.time = formatTime(new Date());
        message.avatar = localStorage.getItem("avatarId") || '0';
        message.msg = text.value;
        socket.send(JSON.stringify(message));
        message.msg = "";
        text.value = "";
    }
}
onActivated(() => {
    console.log(room.value);
    nickname.value = localStorage.getItem("nickName")
    avatarId.value = localStorage.getItem("avatarId");
    if (nickname.value == null && avatarId.value == null) {
        router.push("/hall");
        return;
    }

    // æŸ¥è¯¢æµè§ˆå™¨æ˜¯å¦æ”¯æŒ WebSocket
    if (typeof WebSocket == "undefined") {
        alert("æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ WebSocket");
        router.push("/");
        return;
    }
    // å¼€å¯ WebSocket æœåŠ¡
    let socketHost = "localhost";
    let socketPort = "8080";
    let socketUrl =
        "ws://" + socketHost + ":" + socketPort + "/socket/" + room.value + '/' + nickname.value + '/' + avatarId.value;
    socket = getWebSocket(socketUrl);
    // socket = new WebSocket(socketUrl);
    // è¿æ¥æœåŠ¡å™¨
    socket.onopen = () => {
        console.log("å·²è¿æ¥è‡³æœåŠ¡å™¨");
    };

    // æµè§ˆå™¨æ¥æ”¶æœåŠ¡ç«¯å‘é€çš„æ¶ˆæ¯
    socket.onmessage = (msg) => {
        let data = JSON.parse(msg.data);
        if (data.userlist) {
            // æ¥æ”¶ç”¨æˆ·åˆ—è¡¨æ¶ˆæ¯
            userList.value = data.userlist;
            userCount.value = data.userlist.length;
            chatUsersStore.setUserList(userList.value);
            chatUsersStore.setUserCount(userCount.value);
            console.log(userList.value);
        } else if (data.type === 'musicInfo') {
            // æ¥æ”¶éŸ³ä¹ä¿¡æ¯
            console.log("------------------------");
            console.log(data.data);
            statusStore.setSongIndex(data.data.currentIndex);
            statusStore.setcurrentSongTime(data.data.currentTime);
            console.log("------------------------");

            // musicInfo.value = data.data;

        } else if (data.type === 'portalMsg') {
            // æ¥æ”¶éŸ³ä¹ä¿¡æ¯
            portalMsges.value.push(data);


        } else if (data.time) {
            // æ¥æ”¶æ¶ˆæ¯
            messages.value.push(data);
            CurrentMessageStore.setCurrentMessage(room.value, data.name, data.time, data.msg)
            MessageStore.addMessage(room.value, data);
        }
    };
    // å…³é—­æœåŠ¡
    socket.onclose = () => {
        console.log("WebSocket æœåŠ¡å·²å…³é—­");
    };
    // é”™è¯¯äº‹ä»¶
    socket.onerror = () => {
        console.log("WebSocket æœåŠ¡å‘ç”Ÿé”™è¯¯");
    };
})
// åœ¨ç»„ä»¶å¸è½½å‰å…³é—­ WebSocket è¿æ¥
// åœ¨è·¯ç”±ç¦»å¼€å‰å…³é—­ WebSocket è¿æ¥
onBeforeRouteLeave((to, from, next) => {
    if (socket) {
        console.log("ç¦»å¼€");
        socket.close();
    }
    next();
})
// æ—¥æœŸè½¬æ¢
const formatTime = (date: Date) => {
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const hour = date.getHours();
    const minute = date.getMinutes();
    const second = date.getSeconds();

    return (
        [year, month, day].map(formatNumber).join("-") +
        " " +
        [hour, minute, second].map(formatNumber).join(":")
    );
};
const formatNumber = (n: number) => {
    const s = n.toString();
    return s[1] ? s : "0" + s;
};

const handleKeyUp = (event: KeyboardEvent) => {
    if (event.key === 'Enter') {
        sendMessage();
    }
};
// ç›‘å¬ portalMsges çš„å˜åŒ–
watch(portalMsges, () => {
    const container = document.querySelector('.portalMsgesContainer') as HTMLElement;
    if (container && container.scrollHeight > container.clientHeight) {
        container.scrollTop = container.scrollHeight;
    }
}, { deep: true });
</script>

<template>
    <!-- <div v-for="message in messages" :key="message">
        {{ message.name }} <span>{{ message.time }}</span>
        {{ message.msg }}
    </div> -->
    <div class="portalMsgesContainer">
        <div class="portalMsges" v-for="message in portalMsges" :key="message">
            {{ message.msg }}
        </div>
    </div>
    <div class="footerDiv">
        <div class="footerBar">
            <div class="chatBar">
                <input v-model="text" @keyup="handleKeyUp" class="input-style" type="text">
            </div>
            <div class="imgBtn">
                <img class="sendImg" :src="sendImg" @click="sendMessage">
            </div>
        </div>
    </div>
</template>

<style scoped>
.portalMsgesContainer {
    max-height: 16em;
    /* å®šä¹‰æœ€å¤§é«˜åº¦ */
    overflow-y: auto;
    /* è¶…å‡ºå†…å®¹è‡ªåŠ¨æ»šåŠ¨ */
    line-height: 1.45em;
    overflow: hidden;
}

.portalMsges {
    font-size: .95em;
    position: relative;
    color: #f2f3f2;
}

.footerDiv {
    position: relative;
    width: 100%;
    bottom: 0;
}

.footerBar {
    display: grid;
    height: 3.8em;
    /* background-color: beige; */
    grid-template-columns: 1fr 52vw 1fr;
    grid-template-areas: 'l c r';
    justify-items: center;
    background-color: rgba(68, 68, 68, .48);
}

.chatBar {
    grid-area: c;
    width: 100%;
    justify-items: center;
}

.imgBtn {
    grid-area: r;
    padding: .4em .4em;
    width: 100%;

}

.sendImg {
    cursor: pointer;
    width: 2.8em;
    transform: translateX(-4em);
}

.sendImg:hover {
    transform: translateX(-4em) scale(1.1);
}

.input-style {
    margin-top: .3em;
    padding: .4em .4em;
    height: inherit;
    width: 100%;
    border: 2px solid #ccc;
    border-radius: .3em;
    font-size: 1.4em;
    color: #555;
    outline: none;
}
</style>